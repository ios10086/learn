# JS运行机制

## 任务队列

JavaScript语言的一大特点就是单线程，但**js的宿主环境（比如浏览器，Node）是多线程的**，宿主环境通过某种方式（事件驱动）使得js具备了异步的属性。如网络请求，定时器和事件监听 ，浏览器为这些耗时任务开辟了另外的线程， **把回调函数放到js引擎线程里面的任务队列里进行执行。**

> 1. 浏览器内核可以同时运行多个线程进行异步执行
> 2. 这些线程在浏览器内核的控制下相互配合以保持同步。
> 3. 浏览器内核至少会有三个常驻线程
>    Js引擎线程【执行js代码】
>    页面渲染线程【执行网页渲染操作】
>    浏览器事件触发线程
> 4. 浏览器内核中还会有一些**临时线程**,如：http请求线程

定时器或者ajax请求等耗时操作时，浏览器内核会主动的开一个线程来执行他们，以保证不会阻塞当前js引擎线程的执行，如果**没有使用定时器或者ajax，但是我们的操作仍然耗时，可以主动让浏览器给我开一个线程**，为了利用多核CPU的计算能力，HTML5提出**Web Worker**标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。

## 事件和回调函数

> 1. 所有同步任务都在主线程上执行，形成一个[执行栈](http://www.ruanyifeng.com/blog/2013/11/stack.html)（execution context stack）。
> 2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
> 3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
> 4. 主线程不断重复上面的第三步。

"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。

## Event Loop

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。